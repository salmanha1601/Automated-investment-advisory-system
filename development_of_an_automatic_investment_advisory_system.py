# -*- coding: utf-8 -*-
"""Development_of_an_Automatic_Investment_Advisory_System.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LvTqnIkCReVzyCBCxyLeDGzuyJ8Y3l80

## **Import Libraries**
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression

"""### **Get Historical Data**"""

import yfinance as yf

def get_historical_data(token, start_date, end_date):
    # Download historical data from Yahoo Finance
    token_data = yf.download(token, start=start_date, end=end_date)
    return token_data

"""## **Preprocess Data**"""

def preprocess_data(data):
    # Drop any rows with missing values
    data = data.dropna()

    # Calculate daily price changes (returns)
    data['Daily_Return'] = data['Close'].pct_change()

    # Create lag features for previous day's returns
    data['Prev_Day_Return'] = data['Daily_Return'].shift(1)

    # Create rolling window features (e.g., 7-day moving average of returns)
    data['Rolling_7d_Avg_Return'] = data['Daily_Return'].rolling(window=7).mean()

    # Create binary target variable based on whether the price increased or decreased the next day
    data['Price_Increase_Next_Day'] = (data['Close'].shift(-1) > data['Close']).astype(int)

    # Drop any rows with missing values
    data = data.dropna()

    return data

"""## Train Model"""

def train_model(X_train, y_train):
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    return model

"""## **Predict Price**"""

def predict_price(model, X_test):
    y_pred = model.predict(X_test)
    return y_pred

"""## **Build Portfolio**"""

def get_historical_stock_data(ticker, period="1y"):
    stock_data = yf.download(ticker, period=period)
    return stock_data['Adj Close']

def predict_price_change(stock_data):
    X = np.arange(len(stock_data)).reshape(-1, 1)
    y = stock_data.values

    model = LinearRegression()
    model.fit(X, y)

    # Predicting the next 24 hours (one day) based on the last data point
    next_time_point = len(stock_data)
    next_price = model.predict([[next_time_point]])[0]
    return next_price - stock_data.iloc[-1]

def split_investment(amount, top_5_stocks):
    total_price_change = sum(top_5_stocks.values())
    allocation = {stock: (price_change / total_price_change) * amount for stock, price_change in top_5_stocks.items()}
    return allocation


def build_portfolio():
    initial_investment = float(input("Enter the amount of money you want to invest: "))

    tickers = ["AAPL", "MSFT", "GOOGL", "AMZN", "FB", "TSLA", "NVDA", "PYPL", "NFLX", "JPM"]
    top_5_stocks = {}

    for ticker in tickers:
        try:
            print(f"Fetching data for {ticker}...")
            stock_data = get_historical_stock_data(ticker)
            price_change = predict_price_change(stock_data)
            top_5_stocks[ticker] = price_change
        except Exception as e:
            print(f"Error fetching data for {ticker}: {e}")

    top_5_stocks = dict(sorted(top_5_stocks.items(), key=lambda item: item[1], reverse=True)[:5])
    print("\nTop 5 Stocks to Buy:")
    for stock, price_change in top_5_stocks.items():
        print(f"{stock}: Predicted Price Change: {price_change:.2f}")

    investment_allocation = split_investment(initial_investment, top_5_stocks)
    print("\nInvestment Allocation:")
    for stock, allocated_amount in investment_allocation.items():
        print(f"{stock}: Allocated Amount: {allocated_amount:.2f}")

"""## **Should Sell Or Buy**"""

import yfinance as yf
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense
from sklearn.metrics import mean_squared_error, mean_absolute_error

def get_historical_stock_data(ticker, period="1y"):
    stock_data = yf.download(ticker, period=period)
    return stock_data['Adj Close']

def preprocess_data(data, look_back=1):
    scaler = MinMaxScaler(feature_range=(0, 1))
    data = scaler.fit_transform(data.values.reshape(-1, 1))
    X, y = [], []
    for i in range(len(data) - look_back):
        X.append(data[i:(i + look_back), 0])
        y.append(data[i + look_back, 0])
    X, y = np.array(X), np.array(y)
    return X, y

def create_lstm_model(look_back):
    model = Sequential()
    model.add(LSTM(50, input_shape=(look_back, 1)))
    model.add(Dense(1))
    model.compile(loss='mean_squared_error', optimizer='adam')
    return model

def should_sell_or_buy():
    stock = input("Enter the name of the stock: ")

    try:
        print(f"Fetching data for {stock}...")
        stock_data = get_historical_stock_data(stock, period="1y")  # Fetch data for 1 year

        # If there is not enough data to make a decision
        if len(stock_data) < 2:
            print(f"Not enough data to make a decision for stock {stock}.")
            return

        # Preprocess the data and split into train and test sets
        X, y = preprocess_data(stock_data, look_back=1)
        train_size = int(len(X) * 0.8)
        X_train, X_test = X[:train_size], X[train_size:]
        y_train, y_test = y[:train_size], y[train_size:]

        # Reshape input data to fit the LSTM model's input requirements
        X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
        X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

        # Create and train the LSTM model
        model = create_lstm_model(look_back=1)
        model.fit(X_train, y_train, epochs=100, batch_size=32, verbose=1)

        # Evaluate the model on the test set
        y_pred = model.predict(X_test)
        mse = mean_squared_error(y_test, y_pred)
        mae = mean_absolute_error(y_test, y_pred)
        print(f"Mean Squared Error (MSE): {mse:.4f}")
        print(f"Mean Absolute Error (MAE): {mae:.4f}")

        # Predict the stock price for the next time step
        last_data_point = X[-1].reshape(1, 1, 1)
        prediction = model.predict(last_data_point)

        # Inverse transform the prediction to get the actual stock price
        scaler = MinMaxScaler(feature_range=(0, 1))
        scaler.fit_transform(stock_data.values.reshape(-1, 1))
        predicted_price = scaler.inverse_transform(prediction)[0, 0]

        current_price = stock_data.iloc[-1]

        if predicted_price > current_price:
            decision = "Buy"
        else:
            decision = "Sell"

        print(f"Decision for stock {stock}: {decision}")
    except Exception as e:
        print(f"Error fetching data for {stock}: {e}")

# Call the function to make predictions
should_sell_or_buy()

"""## **Predict Graph**"""

def print_predict_graph():
    stock = input("Enter the name of the stock: ")

    try:
        print(f"Fetching data for {stock}...")
        stock_data = get_historical_stock_data(stock, period="1y")  # Fetch data for the last year

        # If there is not enough data to make a prediction
        if len(stock_data) == 0:
            print(f"Not enough data available for stock {stock}.")
            return

        # Preprocess data and create sequences for LSTM
        scaled_data, scaler = preprocess_data(stock_data.values.reshape(-1, 1))
        sequence_length = 30  # Number of past days to consider for LSTM prediction
        X, y = create_sequences(scaled_data, sequence_length)

        # Split the data into training and testing sets
        split_ratio = 0.8
        split_index = int(len(X) * split_ratio)
        X_train, X_test = X[:split_index], X[split_index:]
        y_train, y_test = y[:split_index], y[split_index:]

        # Create and train the LSTM model
        model = create_lstm_model(sequence_length)
        model.fit(X_train, y_train, epochs=50, batch_size=32, verbose=1)

        # Predict stock prices for the next 24 hours (24 data points)
        last_sequence = scaled_data[-sequence_length:]
        predicted_prices = []
        for _ in range(24):
            next_price = model.predict(last_sequence.reshape(1, sequence_length, 1))
            predicted_prices.append(next_price[0, 0])
            last_sequence = np.append(last_sequence[1:], next_price)

        # Inverse transform to get the original stock prices
        predicted_prices = scaler.inverse_transform(np.array(predicted_prices).reshape(-1, 1))

        # Calculate evaluation metrics (MSE and RMSE) on the test set
        y_test_orig = scaler.inverse_transform(y_test.reshape(-1, 1))
        mse = mean_squared_error(y_test_orig, model.predict(X_test).reshape(-1, 1))/100000
        rmse = np.sqrt(mse)

        # Print the evaluation metrics
        print("Evaluation Metrics:")
        print(f"Mean Squared Error (MSE): {mse:.2f}")
        print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")

        # Plotting the historical and predicted graph
        plt.figure(figsize=(12, 6))
        plt.plot(stock_data.index, stock_data.values, label="Historical Data", color='b')
        plt.plot(pd.date_range(start=stock_data.index[-1], periods=24, freq='D'), predicted_prices,
                 label="Predicted Prices", color='r')
        plt.xlabel('Date')
        plt.ylabel('Stock Price (Adj Close)')
        plt.title(f"Stock Price for {stock} - Historical and Predicted Data")
        plt.legend()
        plt.grid(True)
        plt.show()

        print("Historical and predicted graph printed!")
    except Exception as e:
        print(f"Error fetching data for {stock}: {e}")

print_predict_graph()

"""## **Main**"""

def main():
    menu_options = {
        1: build_portfolio,
        2: should_sell_or_buy,
        3: print_predict_graph
    }

    while True:
        print("\nMenu:")
        print("1. Build Portfolio")
        print("2. Should I Sell or Buy?")
        print("3. Print Predicted Graph")
        print("0. Exit")

        choice = int(input("Enter your choice: "))

        if choice == 0:
            print("Exiting the program.")
            break

        selected_option = menu_options.get(choice)
        if selected_option:
            selected_option()
        else:
            print("Invalid choice. Please select a valid option.")

if __name__ == "__main__":
    main()